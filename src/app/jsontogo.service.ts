/*
The MIT License (MIT)

Copyright (c) 2014 Matt Holt

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class JsonToGoService {
  private go: string = '';
  private accumulator: string = '';
  private stack: string[] = [];
  private seen: Record<string, string[]> = {};
  private tabs: number = 0;
  private innerTabs: number = 0;
  private parent: string = '';

  // Options passed in by the user
  private flatten: boolean = true;
  private example: boolean = false;
  private allOmitempty: boolean = false;

  /**
   * Main entry point: Converts a JSON string into a Go type definition
   * @param json The JSON string to convert
   * @param typename The root struct name (e.g. "MyType")
   * @param flatten Whether to flatten nested structs as separate top-level types
   * @param example Whether to include `example:"..."` tags on fields
   * @param allOmitempty Whether all fields should have `,omitempty`
   * @returns Object with `go` or an `error`
   */
  public jsonToGo(
    json: string,
    typename: string = 'AutoGenerated',
    flatten: boolean = true,
    example: boolean = false,
    allOmitempty: boolean = false
  ): { go: string; error?: string } {
    this.resetState(flatten, example, allOmitempty);

    let data: any;
    let scope: any;
    try {
      data = JSON.parse(json.replace(/(:\s*\[?\s*-?\d*)\.0/g, '$1.1'));
      scope = data;
    } catch (err: any) {
      return { go: '', error: err.message };
    }

    // Start building the Go code
    const topName = this.format(typename || 'AutoGenerated');
    this.append(`type ${topName} `);

    // Parse the root
    this.parseScope(scope, 0);

    // If flatten is on, the code is `this.go + this.accumulator`; else just inline.
    const finalGo = this.flatten ? this.go + this.accumulator : this.go;
    return { go: finalGo };
  }

  private parseScope(value: any, depth: number): void {
    if (typeof value === 'object' && value !== null) {
      if (Array.isArray(value)) {
        // It's an array
        let sliceType: string | undefined;
        const scopeLength = value.length;

        // Determine unified type across all elements
        for (let i = 0; i < scopeLength; i++) {
          const t = this.goType(value[i]);
          if (!sliceType) {
            sliceType = t;
          } else if (sliceType !== t) {
            sliceType = this.mostSpecificPossibleGoType(t, sliceType);
            if (sliceType === 'any') {
              break;
            }
          }
        }

        const sliceNotation = (this.flatten && ['struct', 'slice'].includes(sliceType!))
          ? `[]${this.parent}`
          : '[]';

        if (this.flatten && depth >= 2) {
          this.appender(sliceNotation);
        } else {
          this.append(sliceNotation);
        }

        if (sliceType === 'struct') {
          // An array of objects => gather all fields
          const allFields: Record<string, { value: any; count: number }> = {};
          for (let i = 0; i < scopeLength; i++) {
            const objKeys = Object.keys(value[i]);
            for (const k of objKeys) {
              let keyname = k;
              if (!(keyname in allFields)) {
                allFields[keyname] = { value: value[i][keyname], count: 0 };
              } else {
                // Compare object shape to handle duplicates
                const existingValue = allFields[keyname].value;
                const currentValue = value[i][keyname];
                if (this.compareObjects(existingValue, currentValue)) {
                  // Check keys to see if shapes differ
                  const sameShape = this.compareObjectKeys(
                    Object.keys(currentValue),
                    Object.keys(existingValue)
                  );
                  if (!sameShape) {
                    keyname = keyname + '_' + this.uuidv4();
                    allFields[keyname] = { value: currentValue, count: 0 };
                  }
                }
              }
              allFields[keyname].count++;
            }
          }

          // Create a "common" struct that merges all discovered fields
          const structObj: Record<string, any> = {};
          const omitemptyDict: Record<string, boolean> = {};
          const keys = Object.keys(allFields);
          for (const key of keys) {
            structObj[key] = allFields[key].value;
            omitemptyDict[key] = allFields[key].count !== scopeLength;
          }

          // Recursively parse as a struct
          this.parseStruct(depth + 1, this.innerTabs, structObj, omitemptyDict);

        } else if (sliceType === 'slice') {
          // Nested array
          if (value[0]) {
            this.parseScope(value[0], depth);
          }
        } else {
          // Primitive slice
          if (this.flatten && depth >= 2) {
            this.appender(sliceType || 'any');
          } else {
            this.append(sliceType || 'any');
          }
        }

      } else {
        // It's a plain object
        if (this.flatten) {
          if (depth >= 2) {
            this.appender(this.parent);
          } else {
            this.append(this.parent);
          }
        }
        this.parseStruct(depth + 1, this.innerTabs, value);
      }

    } else {
      // It's a scalar
      if (this.flatten && depth >= 2) {
        this.appender(this.goType(value));
      } else {
        this.append(this.goType(value));
      }
    }
  }

  private parseStruct(
    depth: number,
    innerTabsLocal: number,
    theScope: any,
    omitempty?: Record<string, boolean>
  ): void {
    if (this.flatten) {
      // Push a new line (or empty) onto the stack
      this.stack.push(depth >= 2 ? '\n' : '');
    }

    const seenTypeNames: string[] = [];

    // Flatten + nested level => separate top-level type
    if (this.flatten && depth >= 2) {
      const parentType = `type ${this.parent}`;
      const scopeKeys = this.formatScopeKeys(Object.keys(theScope));

      // If we've already seen an identical shape, skip redefinition
      if (this.parent in this.seen && this.compareObjectKeys(scopeKeys, this.seen[this.parent])) {
        this.stack.pop();
        return;
      }
      this.seen[this.parent] = scopeKeys;

      this.appender(`${parentType} struct {\n`);
      innerTabsLocal++;

      const keys = Object.keys(theScope);
      for (const k of keys) {
        const keyname = this.getOriginalName(k);
        this.indenter(innerTabsLocal);

        const fieldName = this.uniqueTypeName(this.format(keyname), seenTypeNames);
        seenTypeNames.push(fieldName);

        this.appender(fieldName + ' ');
        this.parent = fieldName;

        this.parseScope(theScope[k], depth);

        // JSON tag
        this.appender(' `json:"' + keyname);
        if (this.allOmitempty || (omitempty && omitempty[k] === true)) {
          this.appender(',omitempty');
        }
        if (this.example && theScope[k] !== '' && typeof theScope[k] !== 'object') {
          this.appender('" example:"' + theScope[k]);
        }
        this.appender('"`\n');
      }

      innerTabsLocal--;
      this.indenter(innerTabsLocal);
      this.appender('}');

    } else {
      // Inline struct
      this.append('struct {\n');
      this.tabs++;

      const keys = Object.keys(theScope);
      for (const k of keys) {
        const keyname = this.getOriginalName(k);
        this.indent(this.tabs);

        const fieldName = this.uniqueTypeName(this.format(keyname), seenTypeNames);
        seenTypeNames.push(fieldName);

        this.append(fieldName + ' ');
        this.parent = fieldName;

        this.parseScope(theScope[k], depth);

        // JSON tag
        this.append(' `json:"' + keyname);
        if (this.allOmitempty || (omitempty && omitempty[k] === true)) {
          this.append(',omitempty');
        }
        if (this.example && theScope[k] !== '' && typeof theScope[k] !== 'object') {
          this.append('" example:"' + theScope[k]);
        }
        this.append('"`\n');
      }

      this.tabs--;
      this.indent(this.tabs);
      this.append('}');
    }

    if (this.flatten) {
      // Pop from stack, add to accumulator
      this.accumulator += this.stack.pop();
    }
  }

  private resetState(flatten: boolean, example: boolean, allOmitempty: boolean): void {
    this.go = '';
    this.accumulator = '';
    this.stack = [];
    this.seen = {};
    this.tabs = 0;
    this.innerTabs = 0;
    this.parent = '';
    this.flatten = flatten;
    this.example = example;
    this.allOmitempty = allOmitempty;
  }

  private append(str: string): void {
    this.go += str;
  }

  private appender(str: string): void {
    if (!this.stack.length) {
      // If stack is empty, just in case
      this.stack.push('');
    }
    this.stack[this.stack.length - 1] += str;
  }

  private indent(n: number): void {
    for (let i = 0; i < n; i++) {
      this.go += '\t';
    }
  }

  private indenter(n: number): void {
    let s = '';
    for (let i = 0; i < n; i++) {
      s += '\t';
    }
    if (!this.stack.length) {
      this.stack.push(s);
    } else {
      this.stack[this.stack.length - 1] += s;
    }
  }

  private uniqueTypeName(name: string, used: string[]): string {
    if (!used.includes(name)) {
      return name;
    }
    let i = 0;
    while (true) {
      const newName = name + i.toString();
      if (!used.includes(newName)) {
        return newName;
      }
      i++;
    }
  }

  private format(str: string): string {
    str = this.formatNumber(str);
    let sanitized = this.toProperCase(str).replace(/[^a-z0-9]/gi, '');
    if (!sanitized) return 'NAMING_FAILED';
    return this.formatNumber(sanitized);
  }

  private formatNumber(str: string): string {
    if (!str) return '';
    if (/^\d+$/.test(str)) {
      return 'Num' + str;
    } else if (/\d/.test(str.charAt(0))) {
      const numbers: Record<string, string> = {
        '0': 'Zero_',
        '1': 'One_',
        '2': 'Two_',
        '3': 'Three_',
        '4': 'Four_',
        '5': 'Five_',
        '6': 'Six_',
        '7': 'Seven_',
        '8': 'Eight_',
        '9': 'Nine_'
      };
      return numbers[str.charAt(0)] + str.substr(1);
    }
    return str;
  }

  private goType(val: any): string {
    if (val === null) {
      return 'any';
    }
    switch (typeof val) {
      case 'string':
        // Quick date/time check
        if (/\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)/.test(val)) {
          return 'time.Time';
        }
        return 'string';
      case 'number':
        if (val % 1 === 0) {
          if (val > -2147483648 && val < 2147483647) {
            return 'int';
          }
          return 'int64';
        }
        return 'float64';
      case 'boolean':
        return 'bool';
      case 'object':
        if (Array.isArray(val)) {
          return 'slice';
        }
        return 'struct';
      default:
        return 'any';
    }
  }

  private mostSpecificPossibleGoType(t1: string, t2: string): string {
    if (t1.startsWith('float') && t2.startsWith('int')) {
      return t1;
    } else if (t1.startsWith('int') && t2.startsWith('float')) {
      return t2;
    }
    return 'any';
  }

  private toProperCase(str: string): string {
    if (/^[_A-Z0-9]+$/.test(str)) {
      // SCREAMING_SNAKE_CASE => lower
      str = str.toLowerCase();
    }
    const commonInitialisms = [
      'ACL', 'API', 'ASCII', 'CPU', 'CSS', 'DNS', 'EOF', 'GUID', 'HTML', 'HTTP',
      'HTTPS', 'ID', 'IP', 'JSON', 'LHS', 'QPS', 'RAM', 'RHS', 'RPC', 'SLA',
      'SMTP', 'SQL', 'SSH', 'TCP', 'TLS', 'TTL', 'UDP', 'UI', 'UID', 'UUID',
      'URI', 'URL', 'UTF8', 'VM', 'XML', 'XMPP', 'XSRF', 'XSS'
    ];
    // Title-case logic:
    return str
      .replace(/(^|[^a-zA-Z])([a-z]+)/g, (_match, sep, frag) => {
        if (commonInitialisms.includes(frag.toUpperCase())) {
          return sep + frag.toUpperCase();
        }
        return sep + frag[0].toUpperCase() + frag.slice(1).toLowerCase();
      })
      .replace(/([A-Z])([a-z]+)/g, (_match, sep, frag) => {
        if (commonInitialisms.includes(sep + frag.toUpperCase())) {
          return (sep + frag).toUpperCase();
        }
        return sep + frag;
      });
  }

  private compareObjects(a: any, b: any): boolean {
    const objectTag = '[object Object]';
    return Object.prototype.toString.call(a) === objectTag &&
           Object.prototype.toString.call(b) === objectTag;
  }

  private compareObjectKeys(keysA: string[], keysB: string[]): boolean {
    if (keysA.length !== keysB.length) return false;
    for (const k of keysA) {
      if (!keysB.includes(k)) {
        return false;
      }
    }
    return true;
  }

  private uuidv4(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }

  private getOriginalName(unique: string): string {
    const reLiteralUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    const uuidLength = 36;
    if (unique.length >= uuidLength) {
      const tail = unique.substr(-uuidLength);
      if (reLiteralUUID.test(tail)) {
        return unique.slice(0, -1 * (uuidLength + 1));
      }
    }
    return unique;
  }

  private formatScopeKeys(keys: string[]): string[] {
    return keys.map(k => this.format(k));
  }
}
